<?php

class Validation
{
  
  protected $errors = array();
  protected $rules = array(
    "required",
    "string",
    "email",
    "url",
    "int",
    "max",
    "min",
    "honeyPotValue",
    "honeyPotMicrotime",
    "confirmed",
    "csrf_token",
    "file_format",
    "file_maxsize_total",
  );
  
  public function validate($rules) {

    $request = $_REQUEST;
    $files = $_FILES;

    foreach ($rules as $ruleKey => $rule) {
      if (isset($request[$ruleKey]) || isset($files[$ruleKey])) {
        
        if (isset($request[$ruleKey])) {
          $this->addOld($ruleKey, $request[$ruleKey]); 
        }         
        
        foreach ($rule['rules'] as $ruleItemKey => $ruleItem) {
          if (strpos($ruleItem, ':') !== false) {
            $ruleItemArr = explode(':', $ruleItem);
            if (in_array($ruleItemArr[0], $this->rules)) {
              if (strpos($ruleItemArr[0], 'file') !== false) {
                $this->{$ruleItemArr[0]}($ruleKey, $rule['alias'], $files[$ruleKey], $ruleItemArr[1]);
              } else {
                $this->{$ruleItemArr[0]}($ruleKey, $rule['alias'], $request[$ruleKey], $ruleItemArr[1]);
              }              
            }
          } else {
            if (in_array($ruleItem, $this->rules)) {
              if ($ruleItem == 'confirmed') {
                $this->{$ruleItem}($ruleKey, $rule['alias'], $request);
              } else {
                if (strpos($ruleItem, 'file') !== false) {
                  $this->{$ruleItem}($ruleKey, $rule['alias'], $files[$ruleKey]);
                } else {
                  $this->{$ruleItem}($ruleKey, $rule['alias'], $request[$ruleKey]);
                }
              }             
            }
          }
        }
        
      }
    }
    
    $this->storeErrors();
    if (empty($this->errors)) {
      $_SESSION['form_success'] = true;
      return true;
    } else {
      return false;
    }
    
  }
  
  //Cross Site Request Forgery Prevention
  //CSRF Token Generation
  public static function newCSRFToken() {
    if(session_status() !== PHP_SESSION_ACTIVE)  {
      session_start();
    }
    $_SESSION['csrf_token'] = bin2hex(random_bytes(32));
    return $_SESSION['csrf_token'];
  }
  
  //CSRF Token Verification
  //The field being checked should have value generated by newCSRFToken()
  protected function csrf_token($field, $alias, $value) {
    if (!hash_equals($_SESSION['csrf_token'], $value)) {
      $this->addError($field, "CSRF token is not a match", $value);
    }
  }
  
  protected function addOld($field, $value) {
    if(session_status() !== PHP_SESSION_ACTIVE)  {
      session_start();
    }
    $_SESSION['form_filled'][$field] = $value;
  }
  
  public static function getOld($field) {
    if(session_status() !== PHP_SESSION_ACTIVE)  {
      session_start();
    }
    if (isset($_SESSION['form_filled'][$field])) {
      return $_SESSION['form_filled'][$field];
    } else {
      return '';
    }
  
  }
  
  protected function addError($field, $error, $value) {
    if (isset($this->errors[$field])) {
      array_push($this->errors[$field]['errors'], $error);
    } else {
      $this->errors[$field]['value']  = $value;
      $this->errors[$field]['errors'][0] = $error;
    }
  }
  
  protected function storeErrors() {
    if(session_status() !== PHP_SESSION_ACTIVE)  {
      session_start();
    }
    
    $_SESSION['form_errors'] = $this->errors;
  }
  
  public static function getFormErrors() {
    if(session_status() !== PHP_SESSION_ACTIVE)  {
      session_start();
    }
    
    if (isset($_SESSION['form_errors'])) {
      return $_SESSION['form_errors'];
    } else {
      return array();
    }
    
  }
  
  public static function formSuccess() {
    if(session_status() !== PHP_SESSION_ACTIVE)  {
      session_start();
    }
    
    if (isset($_SESSION['form_success'])) {
      return true;
    } else {
      return false;
    }
  }

  public static function clear() {
    if(session_status() !== PHP_SESSION_ACTIVE)  {
      session_start();
    }

    if (isset($_SESSION['form_errors'])) {
      unset($_SESSION['form_errors']);
    }
    
    if (isset($_SESSION['form_success'])) {
      unset($_SESSION['form_success']);
    }
  }
  
  protected function required($field, $alias, $value) {
    if (empty($value)) {
      $this->addError($field, $alias." cannot be empty", $value);
    }
  }
  
  protected function string($field, $alias, $value) {
    if (!is_string($value)) {
      $this->addError($field, $alias." isn't a string", $value);
    }
  }
  
  protected function email($field, $alias, $value) {
    if (filter_var($value, FILTER_VALIDATE_EMAIL) === false) {
      $this->addError($field, $alias." isn't a valid email address", $value);
    }
  }
  
  protected function url($field, $alias, $value)
  {
    if (filter_var($value, FILTER_VALIDATE_URL) === false) {
      $this->addError($field, $alias." isn't a valid URL address", $value);
    }
  }
  
  protected function int($field, $alias, $value) {   
    if (filter_var($value, FILTER_VALIDATE_INT) === false) {
      $this->addError($field, $alias." isn't an integer", $value);
    }
  }
  
  protected function min($field, $alias, $value, int $min) {
    if (strlen($value) < $min) {
      $this->addError($field, $alias." is inferior to ".$min." characters", $value);
    }
  }
  
  protected function max($field, $alias, $value, int $max) {
    if (strlen($value) > $max) {
      $this->addError($field, $alias." is over ".$max." characters", $value);
    }
  }

  protected function file_format($field, $alias, $value, $formats) {
    $formats = explode('_', $formats);
    
    if (is_array($value['name'])) {
      //Multiple
      $allowed = true;
      foreach ($value['name'] as $fileKey => $fileName) {
        if (!File::isAllowedFormat($fileName, $formats)) {
          $allowed = false;
        }
      }
    } else {
      //Single
      $allowed = File::isAllowedFormat($value['name'], $formats);
    }
    
    if (!$allowed) {
      $this->addError($field, $alias." is not in the allowed formats.", $value);
    }
  }

  protected function file_maxsize_total($field, $alias, $value, $maxSize) {
    $totalSize = 0;

    $allowed = true;
    if (is_array($value['name'])) {
      //Multiple   
      foreach ($value['size'] as $fileKey => $fileSize) {
        $totalSize += $fileSize;
        if ($totalSize > $maxSize) {
          $allowed = false;
        }
      }
    } else {
      //Single
      if ($totalSize > $value['size']) {
        $allowed = false;
      }
    }

    if (!$allowed) {
      $this->addError($field, $alias." is over the total file size limit allowed.", $value);
    }

  }

  protected function file_maxsize_every($field, $alias, $value, $maxSize) {
    $totalSize = 0;

    $oversized = 0;
    if (is_array($value['name'])) {
      //Multiple   
      foreach ($value['size'] as $fileKey => $fileSize) {
        if ($totalSize > $fileSize) {
          $oversized++;
        }
      }
    } else {
      //Single
      if ($totalSize > $value['size']) {
        $oversized++;
      }
    }

    if ($oversized) {
      $this->addError($field, $alias." has $oversized files over the allowed size limit.", $value);
    }

  }
  
  //HoneyPot
  protected function honeyPotValue($field, $alias, $value) {
    if ($value != '') {
      $this->addError($field, "Spam is not allowed", $value);
    }
  }
  
  protected function honeyPotMicrotime($field, $alias, $value) {    
    $now     = microtime(true);
    if (empty($value)) {
      $value = $now;
    }
    if (($now - $value) < 4) {
      //Failed time check, too quick to be a user...
      //Probably a bot...
      $this->addError($field, "Spam is not allowed", $value);
    }
  }
  
  //Confirmation
  //Repeat password and stuff like that...
  protected function confirmed($field, $alias, $values) {
    $confirmationSuffix = '_confirmation';
    if (isset($values[$field.$confirmationSuffix])) {
      if ($values[$field] == $values[$field.$confirmationSuffix]) {
      } else {
        $this->addError($field, $alias." confirmation field doesn't match the ".$alias." field", $values[$field]);
      }
    } else {
      $this->addError($field, $alias." confirmation field is not defined", $values[$field]);
    }
  }
  
}